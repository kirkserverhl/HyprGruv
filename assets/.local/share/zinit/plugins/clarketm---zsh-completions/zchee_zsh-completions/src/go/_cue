#compdef cue

# -----------------------------------------------------------------------------
# The BSD-3-Clause License
#
# Copyright (c) 2020, The zsh-completions Authors
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of que nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# -----------------------------------------------------------------------------
#
# cuelang.org/go
#
# -----------------------------------------------------------------------------
#
# cue evaluates CUE files, an extension of JSON, and sends them
# to user-defined commands for processing.
#
# Commands are defined in CUE as follows:
#
# 	import "tool/exec"
# 	command: deploy: {
# 		exec.Run
# 		cmd:   "kubectl"
# 		args:  [ "-f", "deploy" ]
# 		in:    json.Encode(userValue) // encode the emitted configuration.
# 	}
#
# cue can also combine the results of http or grpc request with the input
# configuration for further processing. For more information on defining commands
# run 'cue help cmd' or go to cuelang.org/pkg/cmd.
#
# For more information on writing CUE configuration files see cuelang.org.
#
# Usage:
#   cue [command]
#
# Available Commands:
#   cmd         run a user-defined shell command
#   def         print consolidated definitions
#   eval        evaluate and print a configuration
#   export      output data in a standard format
#   fix         rewrite packages to latest standards
#   fmt         formats CUE configuration files
#   get         add dependencies to the current module
#   help        Help about any command
#   import      convert other formats to CUE files
#   mod         module maintenance
#   trim        remove superfluous fields
#   version     print CUE version
#   vet         validate data
#
# Flags:
#   -E, --all-errors   print all available errors
#   -h, --help         help for cue
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress
#
# Additional help topics:
#   cue commands  user-defined commands
#   cue filetypes supported file types and qualifiers
#   cue flags     common flags for composing packages
#   cue injection inject values from the command line
#   cue inputs    package list, patterns, and files
#
# Use "cue [command] --help" for more information about a command.#
#
# -----------------------------------------------------------------------------
#
# Append a common snippet of CUE to many files and commit atomically.
#
# Usage:
#   cue add <glob> [--list] [flags]
#
# Flags:
#   -n, --dryrun   only run simulation
#   -h, --help     help for add
#       --list     text executed as Go template with instance info
#
# Global Flags:
#       --debug            give detailed error info
#   -i, --ignore           proceed in the presence of errors
#   -p, --package string   CUE package to evaluate
#   -s, --simplify         simplify output
#       --trace            trace computation
#   -v, --verbose          print information about progress
#
# -----------------------------------------------------------------------------
#
# cmd executes defined the named command for each of the named instances.
#
# Commands define actions on instances. For example, they may
# specify how to upload a configuration to Kubernetes. Commands are
# defined directly in tool files, which are regular CUE files
# within the same package with a filename ending in _tool.cue.
# These are typically defined at the module root so that they apply
# to all instances.
#
# Each command consists of one or more tasks. A task may, for
# example, load or write a file, consult a user on the command
# line, fetch a web page, and so on. Each task has inputs and
# outputs. Outputs are typically filled out by the task
# implementation as the task completes.
#
# Inputs of tasks my refer to outputs of other tasks. The cue tool
# does a static analysis of the configuration and only starts tasks
# that are fully specified. Upon completion of each task, cue
# rewrites the instance, filling in the completed task, and
# reevaluates which other tasks can now start, and so on until all
# tasks have completed.
#
# Available tasks can be found in the package documentation at
#
# 	https://pkg.go.dev/cuelang.org/go/pkg/tool?tab=subdirectories
#
# Examples:
#
# In this simple example, we define a command called "hello",
# which declares a single task called "print" which uses
# "tool/exec.Run" to execute a shell command that echos output to
# the terminal:
#
# 	$ cat <<EOF > hello_tool.cue
# 	package foo
#
# 	import "tool/exec"
#
# 	city: "Amsterdam"
# 	who: *"World" | string @tag(who)
#
# 	// Say hello!
# 	command: hello: {
# 		print: exec.Run & {
# 			cmd: "echo Hello \(who)! Welcome to \(city)."
# 		}
# 	}
# 	EOF
#
# We run the "hello" command like this:
#
# 	$ cue cmd hello
# 	Hello World! Welcome to Amsterdam.
#
# 	$ cue cmd --inject who=Jan hello
# 	Hello Jan! Welcome to Amsterdam.
#
#
# In this example we declare the "prompted" command which has four
# tasks. The first task prompts the user for a string input. The
# second task depends on the first, and echos the response back to
# the user with a friendly message. The third task pipes the output
# from the second to a file. The fourth task pipes the output from
# the second to standard output (i.e. it echos it again).
#
# 	package foo
#
# 	import (
# 		"tool/cli"
# 		"tool/exec"
# 		"tool/file"
# 	)
#
# 	city: "Amsterdam"
#
# 	// Say hello!
# 	command: prompter: {
# 		// save transcript to this file
# 		var: file: *"out.txt" | string @tag(file)
#
# 		ask: cli.Ask & {
# 			prompt:   "What is your name?"
# 			response: string
# 		}
#
# 		// starts after ask
# 		echo: exec.Run & {
# 			cmd:    ["echo", "Hello", ask.response + "!"]
# 			stdout: string // capture stdout
# 		}
#
# 		// starts after echo
# 		file.Append & {
# 			filename: var.file
# 			contents: echo.stdout
# 		}
#
# 		// also starts after echo
# 		print: cli.Print & {
# 			text: echo.stdout
# 		}
# 	}
#
# Run "cue help commands" for more details on tasks and commands.
#
# Usage:
#   cue cmd <name> [inputs] [flags]
#
# Flags:
#   -h, --help                 help for cmd
#   -t, --inject stringArray   set the value of a tagged field
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress#
#
# -----------------------------------------------------------------------------
#
# def prints consolidated configuration as a single file.
#
# Printing is skipped if validation fails.
#
# The --expression flag is used to only print parts of a configuration.
#
# Usage:
#   cue def [flags]
#
# Flags:
#   -e, --expression stringArray   evaluate this expression only
#   -h, --help                     help for def
#   -t, --inject stringArray       set the value of a tagged field
#       --list                     concatenate multiple objects into a list
#       --merge                    merge non-CUE files (default true)
#   -n,--name string              glob filter for file names
#       --out string               output format (run 'cue filetypes' for more info)
#   -o, --outfile string           filename or - for stdout with optional file prefix (run 'cue filetypes' for more info)
#   -p, --package string           package name for non-CUE files
#   -l, --path stringArray         CUE expression for single path component
#   -I, --proto_path stringArray   paths in which to search for imports
#   -d, --schema string            expression to select schema for evaluating values in non-CUE files
#   -A, --show-attributes          display field attributes
#       --with-context             import as object with contextual data
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress
#
# -----------------------------------------------------------------------------
#
# eval evaluates, validates, and prints a configuration.
#
# Printing is skipped if validation fails.
#
# The --expression flag is used to evaluate an expression within the
# configuration file, instead of the entire configuration file itself.
#
# Examples:
#
#   $ cat <<EOF > foo.cue
#   a: [ "a", "b", "c" ]
#   EOF
#
#   $ cue eval foo.cue -e a[0] -e a[2]
#   "a"
#   "c"
#
# Usage:
#   cue eval [flags]
#
# Flags:
#   -a, --all                      show optional and hidden fields
#   -c, --concrete                 require the evaluation to be concrete
#   -e, --expression stringArray   evaluate this expression only
#   -h, --help                     help for eval
#   -t, --inject stringArray       set the value of a tagged field
#       --list                     concatenate multiple objects into a list
#       --merge                    merge non-CUE files (default true)
#   -n,--name string              glob filter for file names
#       --out string               output format (run 'cue filetypes' for more info)
#   -o, --outfile string           filename or - for stdout with optional file prefix (run 'cue filetypes' for more info)
#   -p, --package string           package name for non-CUE files
#   -l, --path stringArray         CUE expression for single path component
#   -I, --proto_path stringArray   paths in which to search for imports
#   -d, --schema string            expression to select schema for evaluating values in non-CUE files
#   -A, --show-attributes          display field attributes
#   -H, --show-hidden              display hidden fields
#   -O, --show-optional            display optional fields
#       --with-context             import as object with contextual data
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress#
#
# -----------------------------------------------------------------------------
#
# export evaluates the configuration found in the current
# directory and prints the emit value to stdout.
#
# Examples:
# Evaluated and emit
#
# 	# a single file
# 	cue export config.cue
#
# 	# multiple files: these are combined at the top-level. Order doesn't matter.
# 	cue export file1.cue foo/file2.cue
#
# 	# all files within the "mypkg" package: this includes all files in the
# 	# current directory and its ancestor directories that are marked with the
# 	# same package.
# 	cue export -p cloud
#
# 	# the -p flag can be omitted if the directory only contains files for
# 	# the "mypkg" package.
# 	cue export
#
# Emit value:
# For CUE files, the generated configuration is derived from the top-level
# single expression, the emit value. For example, the file
#
# 	// config.cue
# 	arg1: 1
# 	arg2: "my string"
#
# 	{
# 		a: arg1
# 		b: arg2
# 	}
#
# yields the following JSON:
#
# 	{
# 		"a": 1,
# 		"b", "my string"
# 	}
#
# In absence of arguments, the current directory is loaded as a package instance.
# A package instance for a directory contains all files in the directory and its
# ancestor directories, up to the module root, belonging to the same package.
# If the package is not explicitly defined by the '-p' flag, it must be uniquely
# defined by the files in the current directory.
#
#
# Formats
# The following formats are recognized:
#
# json    output as JSON
#                Outputs any CUE value.
#
# text    output as raw text
#                 The evaluated value must be of type string.
#
# yaml    output as YAML
#                 Outputs any CUE value.
#
# Usage:
#   cue export [flags]
#
# Flags:
#       --escape                   use HTML escaping
#   -e, --expression stringArray   export this expression only
#   -h, --help                     help for export
#   -t, --inject stringArray       set the value of a tagged field
#       --list                     concatenate multiple objects into a list
#       --merge                    merge non-CUE files (default true)
#   -n,--name string              glob filter for file names
#       --out string               output format (run 'cue filetypes' for more info)
#   -o, --outfile string           filename or - for stdout with optional file prefix (run 'cue filetypes' for more info)
#   -p, --package string           package name for non-CUE files
#   -l, --path stringArray         CUE expression for single path component
#   -I, --proto_path stringArray   paths in which to search for imports
#   -d, --schema string            expression to select schema for evaluating values in non-CUE files
#       --with-context             import as object with contextual data
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress#
#
# -----------------------------------------------------------------------------
#
# Fmt formats the given files or the files for the given packages in place
#
# Usage:
#   cue fmt [-s] [packages] [flags]
#
# Flags:
#   -h, --help   help for fmt
#
# Global Flags:
#       --debug            give detailed error info
#   -i, --ignore           proceed in the presence of errors
#   -p, --package string   CUE package to evaluate
#   -s, --simplify         simplify output
#       --trace            trace computation
#   -v, --verbose          print information about progress
#
# -----------------------------------------------------------------------------
#
# Get downloads packages or modules for CUE or another language
# to include them in the module's pkg directory.
#
# Get requires an additional language field to determine for which
# language definitions should be fetched. If get fetches definitions
# for a language other than CUE, the definitions are extracted from
# the source of the respective language and stored.
# The specifics on how dependencies are fechted and converted vary
# per language and are documented in the respective subcommands.
#
# Usage:
#   cue get <language> [packages] [flags]
#   cue get [command]
#
# Available Commands:
#   go          add Go dependencies to the current module
#
# Flags:
#   -h, --help   help for get
#
# Global Flags:
#       --debug            give detailed error info
#   -i, --ignore           proceed in the presence of errors
#   -p, --package string   CUE package to evaluate
#   -s, --simplify         simplify output
#       --trace            trace computation
#   -v, --verbose          print information about progress
#
# Use "cue get [command] --help" for more information about a command.
#
# -----------------------------------------------------------------------------
#
# go converts Go types into CUE definitions
#
# The command "cue get go" is like "go get", but converts the retrieved Go
# packages to CUE. The retrieved packages are put in the CUE module's pkg
# directory at the import path of the corresponding Go package. The converted
# definitions are available to any CUE file within the CUE module by using
# this import path.
#
# The Go type definitions are converted to CUE based on how they would be
# interpreted by Go's encoding/json package. Definitions for a Go file foo.go
# are written to a CUE file named foo_go_gen.cue.
#
# It is safe for users to add additional files to the generated directories,
# as long as their name does not end with _gen.*.
#
#
# Rules of Converting Go types to CUE
#
# Go structs are converted to cue structs adhering to the following conventions:
#
# 	- field names are translated based on the definition of a "json" or "yaml"
# 	  tag, in that order.
#
# 	- embedded structs marked with a json inline tag unify with struct
# 	  definition. For instance, the Go struct
#
# 	    struct MyStruct {
# 			Common  json:",inline"
# 			Field string
# 		 }
#
# 	  translates to the CUE struct
#
# 		 #MyStruct: Common & {
# 			 Field: string
# 		 }
#
# 	- a type that implements MarshalJSON, UnmarshalJSON, MarshalYAML, or
# 	  UnmarshalYAML is translated to top (_) to indicate it may be any
# 	  value. For some Go core types for which the implementation of these
# 	  methods is known, like time.Time, the type may be more specific.
#
# 	- a type implementing MarshalText or UnmarshalText is represented as
# 	  the CUE type string
#
# 	- slices and arrays convert to CUE lists, except when the element type is
# 	  byte, in which case it translates to the CUE bytes type.
# 	  In the case of arrays, the length of the CUE value is constrained
# 	  accordingly, when possible.
#
# 	- Maps translate to a CUE struct, where all elements are constrained to
# 	  be of Go map element type. Like for JSON, maps may only have string keys.
#
# 	- Pointers translate to a sum type with the default value of null and
# 	  the Go type as an alternative value.
#
# 	- Field tags are translated to CUE's field attributes. In some cases,
# 	  the contents are rewritten to reflect the corresponding types in CUE.
# 	  The @go attribute is added if the field name or type definition differs
# 	  between the generated CUE and the original Go.
#
#
# Native CUE Constraints
#
# Native CUE constraints may be defined in separate cue files alongside the
# generated files either in the original Go directory or in the generated
# directory. These files can impose additional constraints on types and values
# that are not otherwise expressible in Go. The package name for these CUE files
# must be the same as that of the Go package.
#
# For instance, for the type
#
# 	package foo
#
#     type IP4String string
#
# defined in the Go package, one could add a cue file foo.cue with the following
# contents to allow IP4String to assume only valid IP4 addresses:
#
# 	package foo
#
# 	// IP4String defines a valid IP4 address.
# 	#IP4String: =~#"^\#(byte)\.\#(byte)\.\#(byte)\.\#(byte)$"#
#
# 	// byte defines string allowing integer values of 0-255.
# 	byte = #"([01]?\d?\d|2[0-4]\d|25[0-5])"#
#
#
# The "cue get go" command copies any cue files in the original Go package
# directory that has a package clause with the same name as the Go package to the
# destination directory, replacing its .cue ending with _gen.cue.
#
# Alternatively, the additional native constraints can be added to the generated
# package, as long as the file name does not end with _gen.cue.
# Running cue get go again to regenerate the package will never overwrite any
# files not ending with _gen.*.
#
#
# Constants and Enums
#
# Go does not have an enum or sum type. Conventionally, a type that is supposed
# to be an enum is followed by a const block with the allowed values for that
# type. However, as that is only a guideline and not a hard rule, these cases
# cannot be translated to CUE disjunctions automatically.
#
# Constant values, however, are generated in a way that makes it easy to convert
# a type to a proper enum using native CUE constraints. For instance, the Go type
#
# 	package foo
#
# 	type Switch int
#
# 	const (
# 		Off Switch = iota
# 		On
# 	)
#
# translates into the following CUE definitions:
#
# 	package foo
#
# 	#Switch: int // enumSwitch
#
# 	enumSwitch: Off | On
#
# 	Off: 0
# 	On:  1
#
# This definition allows any integer value for Switch, while the enumSwitch value
# defines all defined constants for Switch and thus all valid values if Switch
# were to be interpreted as an enum type. To turn Switch into an enum,
# include the following constraint in, say, enum.cue, in either the original
# source directory or the generated directory:
#
# 	package foo
#
# 	// limit the valid values for Switch to those existing as constants with
# 	// the same type.
# 	#Switch: enumSwitch
#
# This tells CUE that only the values enumerated by enumSwitch are valid
# values for Switch. Note that there are now two definitions of Switch.
# CUE handles this in the usual way by unifying the two definitions, in which case
# the more restrictive enum interpretation of Switch remains.
#
# Usage:
#   cue get go [packages] [flags]
#
# Flags:
#   -e, --exclude string   comma-separated list of regexps of entries
#   -h, --help             help for go
#       --local            generates files in the main module locally
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress#
#
# -----------------------------------------------------------------------------
#
# import converts other formats, like JSON and YAML to CUE files
#
# Files can either be specified explicitly, or inferred from the
# specified packages. Within packages, import only looks for JSON
# and YAML files by default (see the "filetypes" help topic for
# more info). This behavior can be overridden by specifying one of
# the following modes:
#
#    Mode       Extensions
#    json       Look for JSON files (.json, .jsonl, .ldjson).
#    yaml       Look for YAML files (.yaml .yml).
#    text       Look for text files (.txt).
#    jsonschema Interpret JSON, YAML or CUE files as JSON Schema.
#    openapi    Interpret JSON, YAML or CUE files as OpenAPI.
#    auto       Look for JSON or YAML files and interpret them as
#               data, JSON Schema, or OpenAPI, depending on
#               existing fields.
#    data       Look for JSON or YAML files and interpret them
#               as data.
#    proto      Convert Protocol buffer definition files and
#               transitive dependencies.
#
# For user-specified files the modes only affect the
#
# auto mode
#
# In auto mode, data files are interpreted based on some marker
# fields. JSON Schema is identified by a top-level "$schema" field
# with a URL of the form "https?://json-schema.org/.*schema#?".
# OpenAPI is identified by the existence of a top-level field
# "openapi", which must have a major semantic version of 3, and
# the info.title and info.version fields.
#
#
# proto mode
#
# Proto mode converts .proto files containing Prototcol Buffer
# definitions to CUE. The -I defines the path for includes. The
# module root is added implicitly if it exists.
#
# The package name for a converted file is derived from the
# go_package option. It can be overridden with the -p flag.
#
# A module root must be specified if a .proto files includes other
# files within the module. Files include from outside the module
# are also imported and stored within the cue.mod directory. The
# import path is defined by either the go_package option or, in the
# absence of this option, the googleapis.com/<proto package>
# convention.
#
# The following command imports all .proto files in all
# subdirectories as well all dependencies.
#
#    cue import proto -I ../include ./...
#
# The module root is implicitly added as an import path.
#
#
# JSON/YAML mode
#
# The -f option allows overwriting of existing files. This only
# applies to files generated for explicitly specified files or
# files contained in explicitly specified packages.
#
# Use the -R option in addition to overwrite files generated for
# transitive dependencies (files written to cue.mod/gen/...).
#
# The -n option is a regexp used to filter file names in the
# matched package directories.
#
# The -I flag is used to specify import paths for proto mode.
# The module root is implicitly added as an import if it exists.
#
# Examples:
#
#   # Convert individual files:
#   $ cue import foo.json bar.json  # create foo.cue and bar.cue
#
#   # Convert all json files in the indicated directories:
#   $ cue import json ./...
#
# The "flags" help topic describes how to assign values to a
# specific path within a CUE namespace. Some examples of that
#
# Examples:
#
#   $ cat <<EOF > foo.yaml
#   kind: Service
#   name: booster
#   EOF
#
#   # include the parsed file as an emit value:
#   $ cue import foo.yaml
#   $ cat foo.cue
#   {
#       kind: Service
#       name: booster
#   }
#
#   # include the parsed file at the root of the CUE file:
#   $ cue import -f foo.yaml
#   $ cat foo.cue
#   kind: Service
#   name: booster
#
#   # include the import config at the mystuff path
#   $ cue import -f -l '"mystuff"' foo.yaml
#   $ cat foo.cue
#   myStuff: {
#       kind: Service
#       name: booster
#   }
#
#   # append another object to the input file
#   $ cat <<EOF >> foo.yaml
#   ---
#   kind: Deployment
#   name: booster
#   replicas: 1
#
#   # base the path values on the input
#   $ cue import -f -l 'strings.ToLower(kind)' -l name foo.yaml
#   $ cat foo.cue
#   service: booster: {
#       kind: "Service"
#       name: "booster"
#   }
#
#   # base the path values on the input and file name
#   $ cue import -f --with-context -l 'path.Base(filename)' -l data.kind foo.yaml
#   $ cat foo.cue
#   "foo.yaml": Service: {
#       kind: "Service"
#       name: "booster"
#   }
#
#   "foo.yaml": Deployment: {
#       kind:     "Deployment"
#       name:     "booster
#       replicas: 1
#   }
#
#   # include all files as list elements
#   $ cue import -f -list -foo.yaml
#   $ cat foo.cue
#   [{
#       kind: "Service"
#       name: "booster"
#   }, {
#       kind:     "Deployment"
#       name:     "booster
#       replicas: 1
#   }]
#
#   # collate files with the same path into a list
#   $ cue import -f -list -l 'strings.ToLower(kind)' foo.yaml
#   $ cat foo.cue
#   service: [{
#       kind: "Service"
#       name: "booster"
#   }
#   deployment: [{
#       kind:     "Deployment"
#       name:     "booster
#       replicas: 1
#   }]
#
#
# Embedded data files
#
# The --recursive or -R flag enables the parsing of fields that are string
# representations of data formats themselves. A field that can be parsed is
# replaced with a call encoding the data from a structured form that is placed
# in a sibling field.
#
# It is also possible to recursively hoist data formats:
#
# Example:
#   $ cat <<EOF > example.json
#   "a": {
#       "data": '{ "foo": 1, "bar": 2 }',
#   }
#   EOF
#
#   $ cue import -R example.json
#   $ cat example.cue
#   import "encoding/json"
#
#   a: {
#       data: json.Encode(_data),
#       _data = {
#           foo: 1
#           bar: 2
#       }
#   }
#
# Usage:
#   cue import [mode] [inputs] [flags]
#
# Flags:
#       --dryrun                   only run simulation
#       --files                    split multiple entries into different files
#   -f, --force                    force overwriting existing files
#   -h, --help                     help for import
#       --list                     concatenate multiple objects into a list
#       --merge                    merge non-CUE files (default true)
#   -n, --name string              glob filter for file names
#   -o, --outfile string           filename or - for stdout with optional file prefix (run 'cue filetypes' for more info)
#   -p, --package string           package name for non-CUE files
#   -l, --path stringArray         CUE expression for single path component
#   -I, --proto_path stringArray   paths in which to search for imports
#   -R, --recursive                recursively parse string values
#   -d, --schema string            expression to select schema for evaluating values in non-CUE files
#       --with-context             import as object with contextual data
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress#
#
# -----------------------------------------------------------------------------
#
# Usage:
#   cue mod <cmd> [arguments] [flags]
#   cue mod [command]
#
# Available Commands:
#   init        initialize new module in current directory
#
# Flags:
#   -h, --help   help for mod
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress
#
# Use "cue mod [command] --help" for more information about a command.#
#
# -----------------------------------------------------------------------------
#
# Init initializes a cue.mod directory in the current directory,
# in effect creating a new module rooted at the current directory.
# The cue.mod directory must not already exist.
# A legacy cue.mod file in the current directory is moved
# to the new subdirectory.
#
# A module name is optional, but if it is not given a packages
# within the module cannot imported another package defined
# in the module.
#
# Usage:
#   cue mod init [module] [flags]
#
# Flags:
#   -f, --force   force moving old-style cue.mod file
#   -h, --help    help for init
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress#
#
# -----------------------------------------------------------------------------
#
# trim removes fields from structs that are already defined by a template
#
# A field, struct, or list is removed if it is implied by a template, a list type
# value, a comprehension or any other implied content. It will modify the files
# in place.
#
# Limitations
# Removal is on a best effort basis. Some caveats:
# - Fields in implied content may refer to fields within the struct in which
#   they are included, but are only resolved on a best-effort basis.
# - Disjunctions that contain structs in implied content cannot be used to
#   remove fields.
# - There is currently no verification step: manual verification is required.
#
# Examples:
#
# 	$ cat <<EOF > foo.cue
# 	light <Name>: {
# 		room:          string
# 		brightnessOff: 0.0 | >=0 & <=100.0
# 		brightnessOn:  100.0 | >=0 & <=100.0
# 	}
#
# 	light ceiling50: {
# 		room:         "MasterBedroom"
# 		brightnessOn:  100 // this line
# 		brightnessOff: 0   // and this line will be removed
# 	}
# 	EOF
#
# 	$ cue trim foo.cue
# 	$ cat foo.cue
# 	light <Name>: {
# 		room:          string
# 		brightnessOff: 0.0 | >=0 & <=100.0
# 		brightnessOn:  100.0 | >=0 & <=100.0
# 	}
#
# 	light ceiling50: {
# 		room: "MasterBedroom"
# 	}
#
# It is guaranteed that the resulting files give the same output as before the
# removal.
#
# Usage:
#   cue trim [flags]
#
# Flags:
#   -h, --help         help for trim
#   -o, --outfile string   filename or - for stdout with optional file prefix (run 'cue filetypes' for more info)
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress#
#
# -----------------------------------------------------------------------------
#
# print CUE version
#
# Usage:
#   cue version [flags]
#
# Flags:
#   -h, --help   help for version
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress#
#
# -----------------------------------------------------------------------------
#
# vet validates CUE and other data files
#
# By default it will only validate if there are no errors.
# The -c validates that all regular fields are concrete.
#
#
# Checking non-CUE files
#
# Vet can also check non-CUE files. The following file formats are
# currently supported:
#
#   Format       Extensions
# 	JSON       .json .jsonl .ndjson
# 	YAML       .yaml .yml
# 	TEXT       .txt  (validate a single string value)
#
# To activate this mode, the non-cue files must be explicitly mentioned on the
# command line. There must also be at least one CUE file to hold the constraints.
#
# In this mode, each file will be verified against a CUE constraint. If the files
# contain multiple objects (such as using --- in YAML), they will all be verified
# individually.
#
# By default, each file is checked against the root of the loaded CUE files.
# The -e can be used to only verify files against the result of an expression
# evaluated within the CUE files. This can be useful if the CUE files contain
# a set of definitions to pick from.
#
# Examples:
#
#   # Check files against a CUE file:
#   cue vet foo.yaml foo.cue
#
#   # Check files against a particular expression
#   cue vet translations/*.yaml foo.cue -e Translation
#
# If more than one expression is given, all must match all values.
#
# Usage:
#   cue vet [flags]
#
# Flags:
#   -c, --concrete                 require the evaluation to be concrete
#   -h, --help                     help for vet
#   -t, --inject stringArray       set the value of a tagged field
#       --list                     concatenate multiple objects into a list
#       --merge                    merge non-CUE files (default true)
#   -n, --name string              glob filter for file names
#   -p, --package string           package name for non-CUE files
#   -l, --path stringArray         CUE expression for single path component
#   -I, --proto_path stringArray   paths in which to search for imports
#   -d, --schema string            expression to select schema for evaluating values in non-CUE files
#       --with-context             import as object with contextual data
#
# Global Flags:
#   -E, --all-errors   print all available errors
#   -i, --ignore       proceed in the presence of errors
#   -s, --simplify     simplify output
#       --strict       report errors for lossy mappings
#       --trace        trace computation
#   -v, --verbose      print information about progress#
#
# -----------------------------------------------------------------------------

function _cue() {
  local context curcontext=$curcontext state line expl ret=1
  declare -A opt_args

  local -a commands
  commands=(
    'add:bulk append to CUE files'
    'cmd:run a user-defined shell command'
    'def:print consolidated definitions'
    'eval:evaluate and print a configuration'
    'fix:rewrite packages to latest standards'
    'export:output data in a standard format'
    'fmt:formats CUE configuration files'
    'get:add dependencies to the current module'
    'help:Help about any command'
    'import:convert other formats to CUE files'
    'mod:module maintenance'
    'trim:remove superfluous fields'
    'version:print CUE version'
    'vet:validate CUE configurations'
  )

  local -a _gloabal_flags
  _gloabal_flags=(
    {-E,--all-errors}'[print all available errors]'
    {-i,--ignore}'[proceed in the presence of errors]'
    {-s,--simplify}'[simplify output]'
    '--strict[report errors for lossy mappings]'
    '--trace[trace computation]'
    {-v,--verbose}'[print information about progress]'
  )

  function _cue_files() {
    _alternative '*:cue file:_path_files -g "**/*.cue(-.)"'
  }

  _arguments -C \
    $_gloabal_flags \
    "1: :{_describe 'cue commands' commands}" \
    '*:: :->args' \
    && ret=0

  case $state in
    args)
      case $words[1] in
        add)
          _arguments \
            {-n,--dryrun}'[only run simulation]' \
            {-h,--help}'[help for add]' \
            '--list[text executed as Go template with instance info]' \
            {-p,--package}'[package to append to]:package' \
            $_gloabal_flags \
            '*:cue file:_files'
          ;;

        cmd)
          _arguments \
            {-h,--help}'[help for cmd]' \
            {-t,--inject}'[set the value of a tagged field]' \
            $_gloabal_flags \
            '1:name' \
            '*:inputs'
          ;;

        def)
          _arguments \
            {-e,--expression}'[evaluate this expression only]:expressions' \
            {-h,--help}'[help for def]' \
            {-t,--inject}'[set the value of a tagged field]:tag field values' \
            '--list[concatenate multiple objects into a list]' \
            '--merge[merge non-CUE files \(default true\)]' \
            {-n,--name}'[glob filter for file names]:name' \
            '--out[output format]:output format:(cue json yaml jsonl jsonschema openapi proto go text)' \
            {-o,--outfile}'[filename or - for stdout with optional file prefix]:filename:_files' \
            {-p,--package}'[package name for non-CUE files]:package name' \
            {-l,--path}'[CUE expression for single path component]:components' \
            {-I,--proto_path}'[paths in which to search for imports]:proto import paths]' \
            {-d,--schema}'[expression to select schema for evaluating values in non-CUE files]:schema' \
            {-A,--show-attributes}'[display field attributes]' \
            '--with-context[import as object with contextual data]' \
            $_gloabal_flags
          ;;

        eval)
          _arguments \
            {-a,--all}'[show optional and hidden fields]' \
            {-c,--concrete}'[require the evaluation to be concrete]' \
            {-e,--expression}'[evaluate this expression only]:expressions' \
            {-h,--help}'[help for eval]' \
            {-t,--inject}'[set the value of a tagged field]:tag field values' \
            '--list[concatenate multiple objects into a list]' \
            '--merge[merge non-CUE files \(default true\)]' \
            {-n,--name}'[glob filter for file names]:name' \
            '--out[output format]:output format:(cue json yaml jsonl jsonschema openapi proto go text)' \
            {-o,--outfile}'[filename or - for stdout with optional file prefix]:filename:_files' \
            {-p,--package}'[package name for non-CUE files]:package name' \
            {-l,--path}'[CUE expression for single path component]:components' \
            {-I,--proto_path}'[paths in which to search for imports]:proto import paths]' \
            {-d,--schema}'[expression to select schema for evaluating values in non-CUE files]:schema' \
            {-A,--show-attributes}'[display field attributes]' \
            {-H,--show-hidden}'[display hidden attributes]' \
            {-O,--show-optional}'[display optional fields]' \
            '--with-context[import as object with contextual data]' \
            $_gloabal_flags \
            '1:cue file:_cue_files'
          ;;

        export)
          _arguments \
            '--escape[use HTML escaping]' \
            {-e,--expression}'[evaluate this expression only]:expressions' \
            {-h,--help}'[help for export]' \
            {-t,--inject}'[set the value of a tagged field]:tag field values' \
            '--list[concatenate multiple objects into a list]' \
            '--merge[merge non-CUE files \(default true\)]' \
            {-n,--name}'[glob filter for file names]:name' \
            '--out[output format]:output format:(cue json yaml jsonl jsonschema openapi proto go text)' \
            {-o,--outfile}'[filename or - for stdout with optional file prefix]:filename:_files' \
            {-p,--package}'[package name for non-CUE files]:package name' \
            {-l,--path}'[CUE expression for single path component]:components' \
            {-I,--proto_path}'[paths in which to search for imports]:proto import paths]' \
            {-d,--schema}'[expression to select schema for evaluating values in non-CUE files]:schema' \
            '--with-context[import as object with contextual data]' \
            $_gloabal_flags \
            '*:cue file:_cue_files'
          ;;

        fmt)
          _arguments \
            {-h,--help}'[help for fmt]' \
            $_gloabal_flags \
            '*:input file:_cue_files'
          ;;

        get)
          local -a get_commands
          get_commands=(
            'go:add Go dependencies to the current module'
          )

          _arguments -C \
            "1: :{_describe 'cue get commands' get_commands}" \
            $_gloabal_flags \
            '*:: :->args'

          case $words[1] in
            go)
              _arguments \
                {-e,--exclude}'[comma-separated list of regexps of entries]:exclude lists' \
                {-h,--help}'[help for go]' \
                '--local[generates files in the main module locally]' \
                $_gloabal_flags \
                '*:package'
              ;;
          esac
          ;;

        import)
          _arguments \
            '--dryrun[only run simulation]' \
            '--files[split multiple entries into different files]' \
            {-f,--force}'[force overwriting existing files]' \
            {-h,--help}'[help for import]' \
            '--list[concatenate multiple objects into a list]' \
            '--merge[merge non-CUE files \(default true\)]' \
            {-n,--name}'[glob filter for file names]:name' \
            '--out[output format]:output format:(cue json yaml jsonl jsonschema openapi proto go text)' \
            {-o,--outfile}'[filename or - for stdout with optional file prefix]:filename:_files' \
            {-p,--package}'[package name for non-CUE files]:package name' \
            {-l,--path}'[CUE expression for single path component]:components' \
            {-I,--proto_path}'[paths in which to search for imports]:proto import paths]' \
            {-R,--recursive}'[recursively parse string values]' \
            {-d,--schema}'[expression to select schema for evaluating values in non-CUE files]:schema' \
            '--with-context[import as object with contextual data]' \
            $_gloabal_flags \
            '*:input file:_files'
          ;;

        mod)
          local -a mod_commands
          mod_commands=(
            'init:initialize new module in current directory'
          )

          _arguments -C \
            "1: :{_describe 'cue mod commands' mod_commands}" \
            $_gloabal_flags \
            '*:: :->args'

          case $words[1] in
            init)
              _arguments \
                {-f,--force}'[force moving old-style cue.mod file]' \
                {-h,--help}'[help for init]' \
                $_gloabal_flags \
                '1:module'
              ;;
          esac
          ;;

        trim)
          _arguments \
            {-h,--help}'[help for trim]' \
            {-o,--outfile}'[filename or - for stdout with optional file prefix]:filename:_files' \
            $_gloabal_flags \
            '*:cue file:_path_files -g "*.cue(-.)"'
          ;;

        version)
          _arguments \
            $_gloabal_flags \
            {-h,--help}'[help for trim]]'
          ;;

        vet)
          _arguments \
            {-c,--concrete}'[require the evaluation to be concrete]' \
            {-h,--help}'[help for vet]' \
            {-t,--inject}'[set the value of a tagged field]:tag field values' \
            '--list[concatenate multiple objects into a list]' \
            '--merge[merge non-CUE files \(default true\)]' \
            {-n,--name}'[glob filter for file names]:name' \
            '--out[output format]:output format:(cue json yaml jsonl jsonschema openapi proto go text)' \
            {-o,--outfile}'[filename or - for stdout with optional file prefix]:filename:_files' \
            {-p,--package}'[package name for non-CUE files]:package name' \
            {-l,--path}'[CUE expression for single path component]:components' \
            {-I,--proto_path}'[paths in which to search for imports]:proto import paths]' \
            {-d,--schema}'[expression to select schema for evaluating values in non-CUE files]:schema' \
            '--with-context[import as object with contextual data]' \
            $_gloabal_flags \
            '*:files:_files'
          ;;

        help)
          local -a topics
          topics=(
            'commands:user-defined commands'
            'filetypes:supported file types and qualifiers'
            'flags:common flags for composing packages'
            'injection:inject values from the command line'
            'inputs:package list, patterns, and files'
          )
          _arguments "1: :{_describe 'topics' commands -- topics}"
          ;;
      esac
      ;;
  esac

  return ret
}

_cue "$*"

# vim:ft=zsh:et:sts=2:sw=2
